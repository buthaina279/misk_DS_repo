---
title: "ex4"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(pdp)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(rsample)
library(recipes)
library(vip)
library(caret)
```
Using the Boston housing data set from the pdp package, where the response feature is the median value of homes within a census tract (cmedv):

CRIM - per capita crime rate by town
ZN - proportion of residential land zoned for lots over 25,000 sq.ft.
INDUS - proportion of non-retail business acres per town.
CHAS - Charles River dummy variable (1 if tract bounds river; 0 otherwise)
NOX - nitric oxides concentration (parts per 10 million)
RM - average number of rooms per dwelling
AGE - proportion of owner-occupied units built prior to 1940
DIS - weighted distances to five Boston employment centres
RAD - index of accessibility to radial highways
TAX - full-value property-tax rate per $10,000
PTRATIO - pupil-teacher ratio by town
B - 1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town
LSTAT - % lower status of the population
MEDV - Median value of owner-occupied homes in $1000's

```{r}
# access data
housing <- pdp::boston

# initial dimension
dim(housing)

# response variable
head(housing)

# names
names(housing)
```

```{r}
# splitting the data set
set.seed(123)
housing_split <- initial_split(housing, prop = 0.7, strata = "cmedv")
housing_train <- training(housing_split)
housing_test  <- testing(housing_split)
```

##1

```{r}
# create a resampling method
cv <- trainControl(
  method = "repeatedcv", 
  number = 10, 
  repeats = 5
  )
```

- Pick a single feature and apply simple linear regression model.
rm

- Interpret the feature’s coefficient
This coefficient represents the mean increase of cmedv in $9.2924 thousands for every additional one average number of rooms per dwelling(rm). 

- What is the model’s performance?
RMSE is 8.510782
- ****How does it compare to the KNN in the last module?
```{r}
set.seed(123)
(cv_model1 <- train(
  cmedv ~ rm, 
  data = housing_train, 
  method = "lm", #<<
  trControl = cv)
)

summary(cv_model1)
```


##2

- Pick another feature to add to the model.
age

- Before applying the module why do you think this feature will help?
because the age of a home can be influenced by its age 

- Apply a linear regression model with the two features and compare to the simple linear model.

- Interpret the coefficients.
If average number of rooms per dwelling increases by 1 number, the mean of cmdev increases by $8.52146 thousands kilograms. in addition, If proportion of owner-occupied units increase by 1 proportion, the mean of cmdev decreases by -0.07500 thousands dollar

```{r}
set.seed(123)
cv_model2 <- train(
  cmedv ~ rm + age, 
  data = housing_train, 
  method = "lm",
  trControl = cv
  )
summary(cv_model2)
```


##3

- Now apply a model that includes all the predictors.

- How does this model compare to the previous two?

```{r}
set.seed(123)
cv_model3 <- train(
  cmedv ~ ., 
  data = housing_train, 
  method = "lm",
  trControl = cv
  )
summary(cv_model3)
```

##4
Can you identify any model concerns?
through the coefficients ! but how I know!
multicollinearity 
```{r}

```

##5
Apply a principal component regression model.
Perform a grid search over several components.
Identify and explain the performance of the optimal model.

```{r}
# 1. hypergrid
hyper_grid <- expand.grid(ncomp = seq(2, 40, by = 2))
```

?????
```{r}
# 2. PCR
set.seed(123)
cv_pcr_housing <- train(
  cmedv ~ ., 
  data = housing_train, 
  trControl = cv,
  method = "pcr", #<<
  preProcess = c("zv", "center", "scale"), #<<
  tuneGrid = hyper_grid, #<<
  metric = "RMSE"
  )
```


```{r}
# model with lowest RMSE
cv_pcr$bestTune
```


```{r}
cv_pcr$results %>%
  filter(ncomp == as.numeric(cv_pcr$bestTune))

# plot cross-validated RMSE
plot(cv_pcr)
```


##6

Now apply a partial least square model.
Perform a grid search over several components.
Identify and explain the performance of the optimal model.

???

```{r}
# PLS
set.seed(123)
cv_pls_housing <- train(
  cmedv ~ ., 
  data = housing_train, 
  trControl = cv,
  method = "pls", #<<
  preProcess = c("zv", "center", "scale"),
  tuneGrid = hyper_grid,
  metric = "RMSE"
  )
```


```{r}
# model with lowest RMSE
cv_pls_housing$bestTune

cv_pls_housing$results %>%
  filter(ncomp == as.numeric(cv_pls_housing$bestTune))

# plot cross-validated RMSE
plot(cv_pls_housing)
```

